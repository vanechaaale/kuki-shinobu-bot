"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CharacterProfilePicture = void 0;
const config_file_js_1 = require("config_file.js");
const ImageAssets_1 = __importDefault(require("./assets/ImageAssets"));
const TextAssets_1 = __importDefault(require("./assets/TextAssets"));
const Costume_1 = __importDefault(require("./character/Costume"));
const AssetsNotFoundError_1 = __importDefault(require("../errors/AssetsNotFoundError"));
/** @en ProfilePicture */
class ProfilePicture {
    /**
     * @param data
     * @param enka
     */
    constructor(data, enka) {
        this.enka = enka;
        this._data = data;
        const json = new config_file_js_1.JsonReader(this._data);
        this.icon = new ImageAssets_1.default(json.getAsString("iconPath"), enka);
        this.name = new TextAssets_1.default(json.getAsNumber("nameTextMapHash"), enka);
        const keys = enka.cachedAssetsManager.getObjectKeysManager();
        this.type = json.getAsString(keys.profilePictureTypeKey);
    }
    /**
     * @param id
     * @param enka
     */
    static getById(id, enka) {
        var _a;
        const profilePicture = (_a = enka.cachedAssetsManager.getGenshinCacheData("ProfilePictureExcelConfigData").findArray((_, p) => p.getAsNumber("id") === id)) === null || _a === void 0 ? void 0 : _a[1];
        if (!profilePicture)
            throw new AssetsNotFoundError_1.default("ProfilePicture", id);
        const keys = enka.cachedAssetsManager.getObjectKeysManager();
        const type = profilePicture.getAsString(keys.profilePictureTypeKey);
        switch (type) {
            case "PROFILE_PICTURE_UNLOCK_BY_AVATAR":
            case "PROFILE_PICTURE_UNLOCK_BY_COSTUME":
                return new CharacterProfilePicture(profilePicture.getAsJsonObject(), enka);
            default:
                return new ProfilePicture(profilePicture.getAsJsonObject(), enka);
        }
    }
    /**
     * @deprecated
     * @param characterId
     * @param costumeId
     */
    static getByOldFormat(characterId, costumeId, enka) {
        var _a;
        const iconType = costumeId === null ? "PROFILE_PICTURE_UNLOCK_BY_AVATAR" : "PROFILE_PICTURE_UNLOCK_BY_COSTUME";
        const referenceId = costumeId === null ? characterId : costumeId;
        const keys = enka.cachedAssetsManager.getObjectKeysManager();
        const profilePictureData = (_a = enka.cachedAssetsManager.getGenshinCacheData("ProfilePictureExcelConfigData").findArray((_, p) => p.getAsString(keys.profilePictureTypeKey) === iconType && p.getAsNumber(keys.profilePictureReferenceIdKey) === referenceId)) === null || _a === void 0 ? void 0 : _a[1];
        return new CharacterProfilePicture(profilePictureData.getAsJsonObject(), enka);
    }
}
exports.default = ProfilePicture;
/**
 * @en CharacterProfilePicture
 * @extends {ProfilePicture}
 */
class CharacterProfilePicture extends ProfilePicture {
    /**
     * @param data
     * @param enka
     */
    constructor(data, enka) {
        super(data, enka);
        const json = new config_file_js_1.JsonReader(this._data);
        const keys = enka.cachedAssetsManager.getObjectKeysManager();
        const type = json.getAsString(keys.profilePictureTypeKey);
        if (type !== "PROFILE_PICTURE_UNLOCK_BY_AVATAR" && type !== "PROFILE_PICTURE_UNLOCK_BY_COSTUME")
            throw new Error("Invalid type for CharacterProfilePicture");
        const referenceId = keys.profilePictureReferenceIdKey;
        const costume = type === "PROFILE_PICTURE_UNLOCK_BY_COSTUME"
            ? Costume_1.default.getById(json.getAsNumber(referenceId), enka)
            : Costume_1.default.getDefaultCostumeByCharacterId(json.getAsNumber(referenceId), enka);
        this.type = type;
        this.costume = costume;
    }
}
exports.CharacterProfilePicture = CharacterProfilePicture;
